# 告别 AI 聊天的"闪烁"烦恼：深入浅出 Markdown River 架构设计

你有没有在使用 ChatGPT、Claude 或其他 AI 聊天工具时，看到过这样的现象：当 AI 回复包含**加粗**或*斜体*文字时，屏幕上会先显示星号，然后突然变成格式化的文字？这种"闪烁"效果让人感觉产品不够精致，体验也不流畅。

今天，我想和大家分享一个专门解决这个问题的开源项目 —— Markdown River，以及它背后的架构设计思路。

## 一、问题的根源：为什么会闪烁？

### 1.1 AI 回复的特点

首先，我们要理解 AI 是怎么回复的。当你问 AI 一个问题时，它不是一次性把整个答案发给你，而是像人打字一样，一个字一个字地"流式"返回。

比如，当 AI 想发送 `**这是加粗文字**` 时，实际的数据流是这样的：

```
第1个字符: *
第2个字符: *
第3个字符: 这
第4个字符: 是
...
倒数第2个字符: *
倒数第1个字符: *
```

### 1.2 传统渲染器的困境

传统的 Markdown 渲染器（比如 react-markdown）是这样工作的：

1. 收到第一个 `*` → 显示一个星号
2. 收到第二个 `*` → 显示两个星号
3. 收到"这是加粗文字" → 继续显示普通文字
4. 收到最后两个 `*` → 突然意识到："哦！这整个是加粗格式！"
5. 瞬间把所有内容变成加粗，星号消失

这个"突变"的过程就是我们看到的闪烁！

### 1.3 为什么不能简单地等待？

你可能会想：那我们等一下，确认是格式符号再显示不就好了？

问题是：

- 如果等太久，用户会感觉 AI "卡住了"
- 如果不等，又会出现闪烁
- 如何在"不卡"和"不闪"之间找到平衡？

## 二、Markdown River 的解决方案：乐观更新

### 2.1 核心理念：像人类一样思考

想象一下，当你看到一段文字以 `**` 开头时，你会怎么想？

大多数人会立即预期："哦，这应该是加粗文字的开始。"

Markdown River 就是模仿这种人类的预期模式——**乐观更新**：

- 看到 `*` → 预测可能是斜体
- 看到 `**` → 预测应该是加粗
- 看到 ``` → 预测应该是代码块

### 2.2 极简架构设计

经过多次迭代，我们发现最好的设计往往是最简单的。现在的 Markdown River 只有两个核心组件：

```
┌─────────────────────────────────────────────────┐
│              用户 API 接口                       │
├─────────────────────────────────────────────────┤
│                核心组件层                         │
│  ┌──────────────┐         ┌──────────────────┐ │
│  │  增量解析器  │ ──────> │    渲染引擎      │ │
│  │  (乐观预测)  │         │   (即时渲染)     │ │
│  └──────────────┘         └──────────────────┘ │
├─────────────────────────────────────────────────┤
│                支撑模块层                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────────┐ │
│  │ 事件总线 │  │ DOM管理器│  │  样式处理器  │ │
│  └──────────┘  └──────────┘  └──────────────┘ │
└─────────────────────────────────────────────────┘
```

没错，就这么简单！

### 2.3 工作原理详解

让我用一个具体的例子来说明整个流程：

**输入**：`**bold**`（逐字符流式输入）

**处理过程**：

| 输入字符  | 增量解析器的决策         | 渲染输出                |
| --------- | ------------------------ | ----------------------- |
| 第1个 `*` | "可能是格式开始，先等等" | （空）                  |
| 第2个 `*` | "确认了，这是加粗！"     | （空，但已准备好）      |
| `b`       | "加粗内容来了"           | `<strong>b</strong>`    |
| `o`       | "继续加粗内容"           | `<strong>bo</strong>`   |
| `l`       | "继续加粗内容"           | `<strong>bol</strong>`  |
| `d`       | "继续加粗内容"           | `<strong>bold</strong>` |
| 第1个 `*` | "可能要结束了"           | `<strong>bold</strong>` |
| 第2个 `*` | "确认结束！"             | `<strong>bold</strong>` |

看到了吗？用户从头到尾看到的都是正确格式的文字，没有任何闪烁！

### 2.4 预期违背机制：快速纠错

我们引入了**"预期违背"（Expectation Violation）**机制来处理预测错误。

#### 什么情况会违背预期？

```javascript
// 常见的预期违背场景
const violations = {
  '* + 空格': '星号后直接跟空格，不太可能是斜体',
  '** + 换行': '两个星号后直接换行，不太可能是加粗',
  '` + 换行': '反引号后直接换行，不太可能是行内代码',
};
```

#### 实时修正示例

输入：`* just one star`

1. 看到 `*` → 预测"可能是斜体"（暂不输出）
2. 看到空格 → **预期违背！**立即输出 `*` 和空格
3. 看到 `j` → 正常输出 `j`

整个过程用户看到的是：

- 10ms: `* `
- 20ms: `* j`
- 30ms: `* ju`
- ...

没有任何闪烁或修正痕迹！

## 三、设计哲学：少即是多

### 3.1 为什么要移除缓冲管理器？

在早期版本中，我们设计了一个复杂的缓冲管理器，想要通过延迟来获得更多"预判"时间。但实践证明：

- **复杂度增加**：代码变得难以理解和维护
- **延迟明显**：用户能感觉到输出的延迟
- **效果有限**：并没有显著改善体验

最终我们意识到：**直接、快速、简单**才是王道。

### 3.2 乐观更新的威力

乐观更新不仅让代码更简单，还带来了更好的用户体验：

1. **零延迟**：每个字符立即响应
2. **自然流畅**：符合人类的阅读预期
3. **优雅降级**：预测错误时也能平滑处理

## 四、技术实现细节

### 4.1 增量解析器的状态机

解析器维护一个简单的状态机：

```typescript
type ParserState =
  | 'NORMAL' // 普通文本
  | 'POTENTIAL_EMPHASIS' // 可能的强调（*或**）
  | 'IN_EMPHASIS' // 确认在强调中
  | 'POTENTIAL_CODE' // 可能的代码
  | 'IN_CODE'; // 确认在代码中
// ... 其他状态
```

### 4.2 令牌系统

解析器生成令牌流，渲染引擎消费这些令牌：

```typescript
// 乐观令牌
{ type: 'BOLD_START', confidence: 'high' }
{ type: 'TEXT', content: 'bold' }
{ type: 'BOLD_END', confidence: 'high' }

// 修正令牌（如果预测错误）
{ type: 'TEXT', content: '*', correction: true }
```

### 4.3 DOM 优化

为了保证性能，DOM 管理器采用了几个优化技巧：

1. **批量更新**：收集多个操作，一次性更新
2. **虚拟节点**：减少实际的 DOM 查询
3. **智能 diff**：只更新真正改变的部分

## 五、如何使用 Markdown River

### 5.1 基础使用

```javascript
// 创建渲染器
const renderer = new StreamingMarkdownRenderer({
  container: document.getElementById('output'),
});

// 处理流式输入
for await (const char of stream) {
  renderer.write(char);
}
renderer.end();
```

就是这么简单！

### 5.2 自定义样式

```javascript
const renderer = new StreamingMarkdownRenderer({
  styleMap: new Map([
    ['strong', 'font-bold text-gray-900'],
    ['em', 'italic'],
    ['code', 'bg-gray-100 px-1 rounded'],
  ]),
});
```

### 5.3 测试你的实现

Markdown River 提供了独特的"指纹测试"框架：

```javascript
// 定义输入（逗号分隔表示逐字符输入）
input: '*,*,b,o,l,d,*,*';

// 定义每个字符后的预期输出
expected: [
  '', // 第1个*
  '', // 第2个*
  '<strong>b</strong>', // b
  '<strong>bo</strong>', // o
  // ...
];
```

这种测试方式让你能精确验证每个字符的渲染结果。

## 六、实战经验与最佳实践

### 6.1 处理复杂场景

**嵌套格式**：`**bold with *italic* text**`

解析器使用上下文栈来处理嵌套：

1. 进入加粗上下文
2. 在加粗中发现斜体
3. 正确渲染嵌套结构

**未闭合格式**：`**this is not closed`

使用超时机制：

- 如果等待时间过长，放弃格式化
- 回退到普通文本显示

### 6.2 性能优化建议

1. **合理的输入粒度**：虽然支持逐字符，但按词或按块输入性能更好
2. **样式缓存**：频繁使用的样式应该缓存
3. **事件节流**：监听事件时注意节流，避免过度渲染

## 七、架构演进的启示

### 7.1 过度设计的陷阱

我们的经历证明：

- 不要为了"可能的需求"增加复杂度
- 先实现最简单的版本，再根据实际需要优化
- 用户体验比技术完美更重要

### 7.2 测试驱动的价值

指纹测试帮助我们：

- 明确期望的行为
- 快速发现问题
- 勇于重构（有测试保护）

### 7.3 倾听用户的声音

最终的简化设计来自用户反馈：

- "为什么有延迟？"
- "能不能更快一点？"
- "我只想要不闪烁就行"

## 八、未来展望

虽然核心功能已经完成，但我们还在探索：

1. **更多 Markdown 语法支持**：表格、脚注、数学公式等
2. **智能预测增强**：基于上下文的更准确预测
3. **插件系统**：让开发者能扩展功能
4. **框架适配器**：React、Vue、Svelte 等

## 九、总结

Markdown River 的成功证明了一个道理：**解决实际问题不需要复杂的方案**。

通过：

- 🎯 **明确的目标**：消除闪烁
- 💡 **简单的方案**：乐观更新
- ⚡ **极简的实现**：两个核心组件
- 🧪 **充分的测试**：指纹测试框架

我们打造了一个既简单又有效的解决方案。

如果你也在开发 AI 应用，或者对流式渲染感兴趣，欢迎试用 Markdown River。让我们一起为用户创造更好的体验！

---

_项目地址：[GitHub - Markdown River](https://github.com/yourusername/markdown-river)_

_如果这篇文章对你有帮助，欢迎点赞和分享！_
