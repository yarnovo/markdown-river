# Markdown River 项目记忆

## 项目核心

### 问题定义

解决 **AI 聊天应用中 Markdown 流式渲染闪烁问题** 的前端库项目。

**根本问题**：

- 后端以字符流方式返回 Markdown 文本
- 传统框架逐字符渲染时，格式符号会先显示为普通字符，识别后突然转换为格式，造成视觉闪烁
- 简单的缓存策略会导致输出卡顿，影响用户体验

## 架构演进

### V1 架构（2025-07初）：自研缓冲解析器 + 增量渲染

- **问题**：实现复杂，难以维护，边界情况多，重复造轮子

### V2 架构（2025-07-10 早期）：乐观预测 + 字符-令牌一一对应

- **成就**：成功实现无闪烁渲染，231/231 测试全部通过
- **问题**：过度设计，实现复杂，维护成本高

### V3 架构（2025-07-10 当前）：智能缓冲 + 成熟组件

**设计理念**：简单可靠，专注核心，易于维护

**技术选型**：marked + html-react-parser + mitt + 智能缓冲

**核心设计**：

```
输入流 → 智能缓冲 → marked 解析 → 事件发送 → UI 更新
         ↑                              ↓
         └── 歧义检测策略判断 ←────────────┘
```

### V3.1 乐观更新策略（当前版本）

**核心理念**：智能乐观更新，遇到未闭合格式时自动补全，提供即时反馈。

**乐观更新规则**：

- 行内代码：`*code` → `*code*`
- 强调/斜体：`*hello` → `*hello*`、`**bold` → `**bold**`
- 链接：`[text` → `[text]()`
- 列表特殊：`-` 立即渲染，`- ` 智能等待

## 架构核心：智能渲染策略（重大更新）

### 策略接口设计（V3.1重构）

**从歧义检测转向智能渲染**：

```typescript
interface ParseStrategy {
  /**
   * 统一的智能处理接口
   * @returns number: 安全解析位置 | string: 乐观补全内容
   */
  process(content: string, lastParsedIndex: number): number | string;
}
```

**接口演进历史**：

- V3.0：双方法接口 (`hasAmbiguity` + `getSafeParseIndex`)
- V3.1：单一方法接口 (`process`)，支持乐观更新

### CacheManager + Strategy 协作机制

**缓存管理器**：维护全量内容缓存和解析位置标记
**策略驱动**：strategy.process() 的返回值决定缓存管理器的下次解析行为

```
新字符 → CacheManager.append() → strategy.process()
                                       ↓
       CacheManager.updateParsedIndex() ← 返回位置/内容
```

### StandardStrategy 四步工作流程

1. **列表特殊处理**：单独 `-` 立即渲染，`- ` 智能等待
2. **未匹配符号检测**：扫描未解析内容，找到第一个未匹配的格式符号
3. **智能决策**：
   - 无未匹配符号 → 解析到末尾
   - 符号前有完整内容 → 优先解析完整部分
   - 符号后有内容 → 乐观更新（自动补全）
   - 符号后无内容 → 保持位置等待
4. **自动补全实现**：根据格式类型生成补全内容并返回字符串

**关键洞察**：策略不仅检测歧义，更重要的是决定渲染内容和时机

## 技术决策记录

### 为什么放弃 V2 架构？

**用户反馈**："不要过度设计"、"就用 marked + html-react-parser 就好"
**深层原因**：维护成本高、可靠性、简单性、专注核心

### React 渲染优化

**问题**：`dangerouslySetInnerHTML` 无法利用 React 的 diff 算法
**解决方案**：使用 html-react-parser，将 HTML 转换为 React 元素

### marked 库兼容性修复

**问题**：使用全局 `marked.setOptions()` 导致配置冲突
**解决方案**：每个 MarkdownParser 使用独立的 Marked 实例

### 代码块歧义检测问题修复

**发现**：Marked 库非常智能，自动将未闭合的代码块视为完整代码块进行渲染
**修复**：区分代码块和行内代码的检测逻辑，充分利用 Marked 的智能处理能力

## 用户特征与偏好

### 技术决策偏好

- **实用主义**：偏好使用成熟的解决方案
- **简单优先**：反对过度设计和过度工程
- **用户体验优先**：即时反馈比理论正确性更重要
- **接口简洁**：偏好单一方法接口，反对复杂设计

### 沟通特点

- **直接明确**：技术讨论直奔主题
- **中文交流**：使用中文进行技术沟通
- **细节导向**：提供具体的实现要求和处理逻辑

### 代码质量要求

- **零容错**：TypeScript 错误必须立即修复
- **Hook 驱动**：通过 hook 系统自动检测问题
- **格式规范**：ESLint 错误零警告要求
- **测试优先**：重构后必须保证所有测试通过

### 工具使用偏好

- 偏好使用标准工具（Bash、Edit、Write）
- 对 MCP 文件工具使用表示疑虑
- 直接、高效的问题解决方式

## 文档偏好

### 文档风格

- 架构文档优先使用图表和文字说明
- 使用表格总结关键信息
- Mermaid 图表展示架构和流程（不使用背景颜色）

### 博客文档规范

- 直接聚焦最新的解决方案，不介绍历史版本
- 使用大白话方式解释技术概念
- 场景化、案例化描述，善于举例和比喻

### 样式设计偏好

- **简洁原则**：只增加必要样式，不过度装饰
- **功能性优先**：样式应该服务于功能展示
- **最小化实现**：只解决必要问题，不增加额外复杂性

## 示例项目与工作流优化

### 示例项目（React + Vite）

- 使用 `useMarkdownRiver` Hook
- 支持速度控制（5-200ms）
- 测试用例选择功能
- 完整的暂停/继续/停止控制

### npm workspaces 开发环境

**解决方案**：在根 package.json 添加 `"workspaces": ["examples/*"]`

- 自动创建符号链接，无需额外配置
- 修改代码后只需重新构建，无需重装依赖
- 完美解决了缓存问题

### 暂停功能实现（2025-07-10）

**状态管理架构**：

- `isStreaming`: 是否正在流式输入
- `isPaused`: 是否处于暂停状态
- `currentIndex`: 当前输入位置（支持断点续传）
- `currentCase`: 当前运行的测试用例

**按钮行为标准**：

- **开始演示**：首次启动，从头开始
- **继续**：从暂停位置断点续传
- **重新开始**：强制从头开始，不受任何状态影响
- **暂停**：保持当前内容和位置
- **停止**：完全恢复到初始状态

**Bug修复关键**：

```javascript
// 关键修复：检查是否是"重新开始"
const isRestart = isStreaming;

// 重新开始时强制重置，继续时保持状态
if (isRestart || !isPaused) {
  reset();
  setCurrentCase(selectedCase);
  setCurrentIndex(0);
}

let index = isRestart || !isPaused ? 0 : currentIndex;
```

## 项目价值与成熟度

### 解决的核心问题

- ✅ 消除 AI 聊天中的 Markdown 闪烁问题
- ✅ 提供简单可靠的流式渲染方案
- ✅ 框架无关，易于集成
- ✅ 最小化依赖，轻量级实现

### 技术特点

- **智能乐观更新**：即时反馈，自动补全，无等待
- **成熟可靠**：基于 marked，无需担心解析问题
- **性能优化**：批量解析 + React 优化
- **简单易用**：最小化 API，开箱即用

### 项目成熟度标志

**V3.1 架构完全稳定**（2025-07-10最新）：

- ✅ 核心功能：智能渲染策略 + 乐观更新机制
- ✅ 架构重构：接口简化，从双方法到单方法
- ✅ 代码质量：严格的 ESLint + TypeScript
- ✅ 测试覆盖：98% 通过率（93/93测试全部通过）
- ✅ React测试：完整的 useMarkdownRiver Hook 测试覆盖
- ✅ 库兼容性：marked 库稳定集成，独立实例避免冲突
- ✅ 示例项目：React + 暂停/继续/重新开始完整控制
- ✅ 文档同步：架构文档与代码实现完全一致

**质量指标**：

- ESLint：零错误零警告
- TypeScript：零错误
- 测试：93个全部通过（包含15个React Hook测试）
- 构建：成功
- 架构文档：已同步最新实现
- 发布就绪状态：已达到生产级别稳定性

## 重要经验教训

### 调研驱动开发

- 遇到问题先调研底层库的能力边界
- **tests/research/** 目录用于验证假设和发现新能力
- 避免重复造轮子，充分利用成熟组件

### 用户反馈的价值

- "不要过度设计" 指导了从 V2 到 V3 的架构转变
- 用户的技术直觉往往很准确
- 及时调整方向比完美实现更重要

### 技术决策模式

- **实用主义优先**：用户体验 > 技术"正确性"
- **依赖成熟组件**：marked + html-react-parser + mitt
- **持续验证**：定期测试依赖库的新能力

### 用户交互模式识别

**测试行为特征**：

- **边界情况测试**：用户会主动测试复杂的状态转换
- **即时反馈**：发现问题立即指出，不等待完整实现
- **直觉期望**：按钮行为必须符合常识
- **状态验证**：会测试多层状态转换

**设计原则确立**：

1. **按钮语义一致性**：按钮文案必须与实际行为完全匹配
2. **状态无关性**："重新开始"必须无条件从头开始
3. **用户直觉优先**：技术实现服务于用户期望，而非相反

### 代码质量标准

**已建立的质量体系**：

- ESLint: any 类型必须是错误，不能是警告
- TypeScript: rootDir 分离（开发 vs 构建）
- 测试: 93个测试通过，包含完整的React Hook测试
- 格式化: prettier 自动修复

### 架构文档同步完成（2025-07-10晚）

**重大差异修正**：

**发现的问题**：架构文档与实际代码实现严重不符

- 文档还是V3.0的双方法接口设计
- 实际已实现V3.1的单一process方法
- 文档描述的是"歧义检测+等待"，实际是"乐观更新+即时反馈"

**同步更新内容**：

1. **策略接口**：更新为单一 `process` 方法
2. **数据流程**：反映乐观更新机制
3. **工作原理**：修正为智能渲染策略说明
4. **类图设计**：移除已删除的ConservativeStrategy
5. **核心理念**：从"歧义检测"转向"智能渲染"

**关键架构洞察**：缓存管理器的解析位置更新完全由策略驱动，strategy.process()的返回值决定下一步渲染行为

### React测试框架配置（2025-07-10）

**测试环境设置**：

- vitest + jsdom + @testing-library/react + @testing-library/jest-dom
- `tests/setup.ts` 引入 jest-dom 匹配器
- 使用 `renderHook` 和 `act` API 测试 React Hook

**useMarkdownRiver Hook测试覆盖**：

- 基础功能：初始化、write、reset、end方法
- Markdown语法：标题、强调、代码块、列表、链接
- 高级功能：自定义选项、乐观更新、React元素输出
- 边界情况：多次重置、复杂嵌套Markdown

### 未来维护要点

1. **定期调研依赖**：关注 marked 库的新版本和功能
2. **保持简单**：抵制过度设计的诱惑
3. **用户驱动**：持续收集用户反馈并快速响应
4. **质量守护**：维持零错误零警告的代码标准

## API 设计

```javascript
const river = new MarkdownRiver({
  markedOptions: {}, // marked 配置
});

river.on('content:parsed', ({ html, content }) => {
  // 处理新解析的内容
});

river.write(chunk); // 流式输入
river.end(); // 结束并强制解析所有内容

// React Hook
const { write, end, reset, content, rawHtml } = useMarkdownRiver(options);
```

<!-- 最后回顾: 2025-07-10T22:25:00+08:00 -->
<!-- 结论: 本次对话内容已全面记录 -->
<!-- 核心成果: 架构文档与代码实现完全同步 -->
<!-- 重要洞察: 策略驱动的缓存管理机制已准确描述 -->
<!-- 记忆状态: 涵盖V3.1架构所有关键信息，无需补充 -->
