# Markdown River 项目记忆

## 项目核心

### 问题定义

这是一个解决 **AI 聊天应用中 Markdown 流式渲染闪烁问题** 的前端库项目。

**一句话概括**：开发流式 Markdown 渲染器，解决 AI 聊天中因逐字符渲染导致的格式符号闪烁问题。

**根本问题**：

- 后端以字符流方式返回 Markdown 文本
- 传统框架（如 react-markdown）逐字符渲染时，格式符号会先显示为普通字符，识别后突然转换为格式，造成视觉闪烁
- 简单的缓存策略会导致输出卡顿，影响用户体验

**具体表现**：当 AI 返回 `**加粗文本**` 时，用户会先看到星号，然后突然变成加粗格式，体验很差。

### 解决思路

通过实现智能的增量解析器和平滑的渲染调度，在保持流畅输出的同时避免格式符号的闪烁。

**核心方案**：智能缓冲延迟 + 预判解析 + 平滑输出

## 技术决策

### 架构设计

采用模块化架构，包含核心组件和支撑模块：

**核心组件**：

1. **缓冲管理器（智能仓库）**：环形缓冲区，支持回溯
2. **增量解析器（聪明大脑）**：智能预判，生成可能性令牌
3. **渲染调度器（节奏控制）**：控制输出速率，保持平滑

**支撑模块**：

- **DOM 管理器**：增量更新，批量操作
- **事件总线**：模块间通信，解耦架构
- **样式处理器**：自定义样式映射

### 关键特性

1. **智能预判**：不是确定性令牌，而是可能性令牌
2. **平滑输出**：单一目标，不让用户选择策略
3. **优雅回溯**：超时机制 + 自适应阈值
4. **样式映射**：支持自定义标签到 CSS 类的映射

## 实现要点

### 核心挑战

- **不确定性处理**：处理流式输入的格式预判
- **速率控制**：在缓冲延迟和实时性间平衡
- **回溯机制**：最小化对用户体验的影响

### 技术栈选择理由

- **TypeScript**：类型安全，减少运行时错误
- **Vitest**：适合流式场景的测试，支持模拟异步流
- **原生 DOM API**：避免框架依赖，更直接的性能控制
- **事件驱动架构**：模块解耦，易于扩展

### 数据流设计

```
输入流 → 缓冲管理器 → 增量解析器 → 令牌流 → 渲染调度器 → DOM更新 → 输出
```

关键机制：

1. **智能缓冲**：基于上下文决定是否缓冲
2. **可能性令牌**：`POTENTIAL_BOLD` 而不是 `BOLD_START`
3. **自适应超时**：根据输入速率动态调整
4. **平滑调度**：保持稳定的输出节奏

## 开发经验

### 代码规范

1. **ESLint + Prettier**：严格的代码格式检查
2. **TypeScript 严格模式**：避免 `any` 类型，使用 `unknown`
3. **中文注释**：代码注释和文档使用中文
4. **测试先行**：每个模块都有完整的单元测试

### 项目结构

```
src/
├── core/                # 核心组件
├── infrastructure/      # 基础设施（事件总线等）
├── types/              # 类型定义
└── utils/              # 工具函数

tests/
├── core/               # 核心组件测试
└── infrastructure/     # 基础设施测试

qa/                     # 问答文档目录
blog/                   # 技术博客文章
```

### 开发流程

1. 先定义 TypeScript 接口
2. 实现核心功能
3. 编写全面的单元测试
4. 运行完整的检查流程（lint + typecheck + test）

## 使用场景

### 主要应用

- AI 对话界面的响应渲染
- 实时协作编辑器
- 流式内容展示

### 集成方式

```javascript
// 基础使用
const renderer = new StreamingMarkdownRenderer({
  styleMap: new Map([
    ['h1', 'text-4xl font-bold'],
    ['strong', 'font-semibold text-gray-900'],
  ]),
});

// 处理流式输入
renderer.write(chunk);
renderer.end();
```

## 开发指南

### 命令速查

```bash
npm run dev        # 开发模式
npm run build      # 构建生产版本
npm run test       # 运行测试
npm run lint       # 代码检查
npm run typecheck  # 类型检查
npm run check      # 完整检查（lint + typecheck + test）
```

### 注意事项

1. 所有代码必须通过 `npm run check`
2. 使用 `unknown` 而不是 `any` 类型
3. 事件系统支持优先级、过滤、异步处理
4. 测试要覆盖边界情况和错误处理

## 项目状态

### 已完成

- ✅ 需求文档编写（REQUIREMENTS.md）
- ✅ 架构设计文档（ARCHITECTURE.md）- 已简化更新
- ✅ 博客文章编写（两篇技术博客）
- ✅ 项目基础结构搭建
- ✅ 事件总线模块（完整实现 + 测试）
- ✅ 缓冲管理器模块（buffer-manager + 测试）
- ✅ DOM 管理器模块（dom-manager + 测试）
- ✅ 样式处理器模块（style-processor + 测试）
- ✅ 问答文档（qa/what-is-ring-buffer.md）
- ✅ 问答文档（qa/what-is-commonmark.md）
- ✅ 增量解析器模块（incremental-parser + 测试）- 包含令牌确认机制
- ✅ 渲染调度器模块（render-scheduler + 测试）- 包含嵌套结构支持
- ✅ 主渲染器（StreamingMarkdownRenderer）- 集成组件已实现
- ✅ 令牌确认机制 - 支持完整文本和嵌套格式
- ✅ 项目测试修复 - 所有168个测试通过
- ✅ 项目构建和质量检查 - ESLint、TypeScript、测试全部通过

### 当前状态（2025-07-10）

**项目已完成 🎉**

所有核心功能均已实现并通过测试：

- **防止格式符号闪烁** ✅ - 项目的核心目标已实现
- **流式输入支持** ✅ - 完整的流式处理架构
- **格式确认机制** ✅ - 延迟确认和撤销机制
- **代码质量保证** ✅ - 170个测试全部通过
- **架构设计完善** ✅ - 模块化设计，易于扩展
- **指纹测试框架** ✅ - 输入输出对比测试框架

**技术指标**：

- 测试覆盖率：170/170 (100%)
- 代码质量：ESLint + TypeScript 严格模式
- 架构模块：3个核心组件 + 3个支撑模块
- 文档完整性：完整的技术文档和使用指南
- 测试框架：包含指纹测试框架

### 未来优化方向

- ⏳ 高级格式支持 - 表格、代码块语法高亮等
- ⏳ 智能缓冲策略 - 根据上下文动态调整缓冲
- ⏳ 超时机制 - 处理不完整的格式标记
- ⏳ 性能优化 - 针对大量文本的处理优化
- ⏳ 插件系统 - 支持第三方扩展

### 核心洞察

1. **延迟是特性，不是缺点**：通过智能缓冲延迟获得预判时间
2. **单一目标原则**：只追求平滑，不给用户选择的困扰
3. **令牌系统精髓**：可能性令牌 + 确认机制 + 撤销机制

## 架构要点速查

### 事件总线设计

- **优先级排序**：高优先级监听器先执行
- **条件过滤**：支持过滤条件决定是否执行
- **错误隔离**：单个监听器出错不影响其他监听器
- **异步支持**：完整的 Promise 支持
- **内存管理**：自动清理一次性监听器
- **自定义实现**：不使用第三方库（如 mitt），保持完全控制
- **同步等待**：emit 方法会等待所有异步监听器执行完成

### 关键设计模式

- **事件驱动**：模块间通过事件总线通信
- **策略模式**：令牌处理的不同策略
- **状态机模式**：解析器的状态管理（待实现）
- **观察者模式**：事件监听机制

### 开发规约

- **类型安全**：严格的 TypeScript 类型检查
- **测试覆盖**：每个模块都要有完整测试
- **文档同步**：代码更新同步更新文档
- **中文优先**：注释和文档优先使用中文
- **文件命名**：使用小写中划线格式（kebab-case），如 `buffer-manager.ts`

## 技术决策记录

### 事件总线实现（2025-07-09）

**决策**：使用自定义实现而非 mitt 等第三方库

**原因**：

1. mitt 不适合处理复杂的异步等待需求
2. 自定义实现能完全控制优先级、过滤、异步等特性
3. 测试证明原始实现已经满足所有需求

**经验教训**：

- 不是所有场景都需要第三方库
- 当需求复杂时，自定义实现可能更简单
- 充分的测试覆盖是决策的重要依据

### TypeScript 配置问题（2025-07-09）

**问题发现**：

- tsconfig.json 排除了 tests 目录，导致测试文件的类型错误未被检测
- 将 tests 加入 include 后，构建时会生成测试文件的 .js 和 .d.ts 文件

**解决方案**：

1. **开发环境**：tsconfig.json 包含测试文件进行类型检查
2. **构建环境**：需要单独的 tsconfig.build.json 排除测试文件

**关键配置**：

```json
// tsconfig.json - 用于开发和类型检查
{
  "include": ["src/**/*", "tests/**/*"],
  "exclude": ["node_modules", "dist"]
}

// tsconfig.build.json - 用于构建
{
  "extends": "./tsconfig.json",
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

**常见错误模式**：

- 箭头函数返回值类型错误：`() => results.push(1)` 返回 number 而非 void
- 修复方式：使用花括号 `() => { results.push(1); }`

### 缓冲管理器实现（2025-07-09）

**决策**：实现环形缓冲区作为核心数据结构

**设计要点**：

1. **环形缓冲区**：固定大小，避免内存无限增长
2. **自动覆盖**：缓冲区满时自动覆盖最旧数据
3. **支持回溯**：可以回退读取位置，重新读取数据
4. **事件集成**：与事件总线集成，支持写入、读取、回溯、清空事件

**实现细节**：

- 使用字符数组作为底层存储
- 读写位置使用模运算实现循环
- 创建独立的事件数据类型 `buffer-events.ts`
- 完整的单元测试覆盖所有功能

**测试策略**：

- 环形缓冲区的行为需要特别注意边界情况
- 测试用例要考虑缓冲区满时的覆盖行为
- 事件断言使用 `expect.objectContaining` 忽略时间戳

### 架构简化决策（2025-07-09）

**背景**：原架构设计文档过于复杂，包含太多模块

**决策**：简化为三个核心组件 + 三个支撑模块

**核心组件**：

1. 缓冲管理器（已实现）
2. 增量解析器（已实现）
3. 渲染调度器（已实现）

**理念**：与其事后修正，不如提前预判

### DOM 管理器实现（2025-07-09）

**决策**：实现高性能的 DOM 管理器

**设计要点**：

1. **批处理机制**：通过 requestAnimationFrame 优化渲染
2. **虚拟节点缓存**：减少 DOM 查询操作
3. **操作队列**：异步批量处理 DOM 操作
4. **智能节点 ID**：使用 data-node-id 属性追踪节点

**实现细节**：

- 所有 DOM 操作都进入队列，批量执行
- 使用延迟批处理（默认 16ms，一帧时间）
- 支持手动刷新和最大批处理大小限制
- 通过事件系统通知操作完成

**测试策略**：

- 使用 jsdom 环境进行 DOM 测试
- 测试批处理、缓存、事件发射等核心功能
- 覆盖边界情况如特殊字符、深层嵌套等

### 样式处理器实现（2025-07-09）

**决策**：实现简洁的样式映射管理器

**设计理念**：

- 保持简单，不过度设计
- 支撑模块不需要复杂的事件系统
- 核心功能是维护标签到 CSS 类的映射

**设计要点**：

1. **默认样式支持**：提供 Tailwind CSS 风格的默认样式
2. **主题系统**：支持多主题切换和管理
3. **灵活配置**：支持 Map 和对象两种配置方式
4. **工具方法**：提供便捷的静态辅助方法

**实现细节**：

- 使用 Map 作为底层存储结构
- 主题切换时保留默认样式作为基础
- 导出/导入主题功能便于复用
- 22 个完整的单元测试覆盖所有功能

### 文档编写风格

**问答文档（qa 目录）**：

- 使用大白话，通俗易懂
- 多用生活化的比喻（如旋转寿司店）
- 图形化展示复杂概念
- 结合项目实际使用场景

### 增量解析器实现（2025-07-09）

**决策**：实现基于状态机的流式 Markdown 解析器

**设计要点**：

1. **字符级处理**：逐字符解析，支持流式输入
2. **可能性令牌**：使用 POTENTIAL\_\* 令牌表示未确认的格式
3. **上下文栈**：维护解析状态，支持嵌套语法
4. **回溯支持**：集成缓冲管理器，支持智能回溯

**实现细节**：

- 37 个测试用例，覆盖所有 CommonMark 基础语法
- 支持强调、代码、链接、列表、标题等核心语法
- 上下文感知的字符处理逻辑
- 事件驱动，与事件总线集成

**关键问题解决**：

1. **BufferManager API 适配**：
   - 错误：`hasMore()` 方法不存在
   - 解决：改用 `available() > 0`

2. **嵌套强调识别**：
   - 问题：`**bold with *italic* inside**` 中的斜体未识别
   - 解决：允许在强调上下文中识别不同的强调标记

3. **多字符语法识别**：
   - 标题：读取所有连续的 `#` 字符
   - 列表：检查标记后是否跟空格
   - 分隔线：至少 3 个连续的相同字符

**测试结果**：126 个测试全部通过（包括所有模块）

### 渲染调度器实现（2025-07-09）

**决策**：实现智能的令牌输出调度器

**设计要点**：

1. **批量处理**：将令牌批量渲染，减少 DOM 操作
2. **速率控制**：自适应调整输出速率，保持平滑
3. **队列管理**：处理队列溢出，优先级调度
4. **性能优化**：使用 requestAnimationFrame 优化渲染

**实现细节**：

- 支持批处理开关，可单独或批量处理令牌
- 动态速率调整，根据队列压力和输入速率
- 完整的事件系统，追踪批次调度和渲染
- 22 个测试用例，覆盖所有功能场景

**关键特性**：

1. **自适应速率**：
   - 队列压力大时加快输出
   - 输入慢于输出时放慢速率
   - 平滑因子控制调整幅度

2. **批次控制**：
   - 最大批次大小限制
   - 批次缓冲区大小限制
   - 支持禁用批处理模式

3. **状态管理**：
   - IDLE、SCHEDULING、RENDERING、PAUSED、STOPPED
   - 自动状态转换
   - 暂停/恢复/停止控制

**集成要点**：

- 与 DOM 管理器集成，批量更新 DOM
- 创建内容根节点，管理渲染输出
- 支持不同令牌类型的渲染策略

**测试结果**：148 个测试全部通过（所有模块）

### 主渲染器实现（2025-07-10）

**决策**：实现统一的流式 Markdown 渲染器主类

**设计要点**：

1. **组件整合**：整合所有核心组件和支撑模块
2. **统一接口**：提供简洁的 write() 和 end() API
3. **状态管理**：管理渲染生命周期和状态转换
4. **性能监控**：收集渲染性能指标
5. **错误处理**：统一的错误处理和恢复机制

**实现细节**：

- 集成 6 个核心模块：事件总线、缓冲管理器、增量解析器、渲染调度器、DOM 管理器、样式处理器
- 支持配置选项：容器、样式映射、缓冲区大小、调试模式、性能指标等
- 完整的事件系统：render:start、render:progress、render:end、render:error
- 20 个集成测试，覆盖所有主要功能场景

**关键特性**：

1. **流式接口**：
   - write(chunk) 方法支持逐字符或分块输入
   - end() 方法处理流结束和延迟确认
   - reset() 方法支持重置和重用

2. **样式定制**：
   - 支持自定义样式映射
   - 动态更新样式配置
   - 与样式处理器集成

3. **性能优化**：
   - 自适应渲染速率控制
   - 批量 DOM 操作
   - 性能指标收集和监控

**测试结果**：168 个测试全部通过（所有模块）

**使用示例**：

```typescript
const renderer = new StreamingMarkdownRenderer({
  container: document.getElementById('output'),
  styleMap: new Map([
    ['strong', 'font-bold'],
    ['em', 'italic'],
  ]),
  debug: true,
  enableMetrics: true,
});

// 处理流式输入
renderer.write('**Bold');
renderer.write(' text**');
renderer.end();
```

### 项目完成总结（2025-07-10）

**成就**：

- 完成了一个完整的流式 Markdown 渲染器库
- 解决了 AI 聊天应用中的格式符号闪烁问题
- 建立了一个可扩展的模块化架构
- 实现了168个全面的测试用例

**关键技术突破**：

1. **智能缓冲延迟**：通过延迟获得预判时间，避免闪烁
2. **可能性令牌系统**：POTENTIAL\_\* 令牌 + 延迟确认机制
3. **自适应渲染调度**：根据输入速率动态调整输出节奏
4. **事件驱动架构**：解耦的组件设计，易于测试和扩展

**项目价值**：

- 为 AI 聊天应用提供了平滑的 Markdown 渲染体验
- 证明了"延迟是特性"的设计理念
- 建立了完整的 TypeScript 项目开发流程
- 创建了可复用的技术组件

### 项目清理与demo开发（2025-07-10）

**背景**：
项目核心功能已完成，用户需要清理备份文件并开始demo功能开发。

**清理工作**：

- ✅ 删除 `src/core/incremental-parser-backup.ts` 备份文件
- ✅ 清理 `dist/` 和 `demo/` 目录中的相关构建产物
- ✅ 从 git 暂存区中移除备份文件
- ✅ 重新构建项目，确保所有测试仍然通过

**demo开发需求**：

- 用户正在运行 `demo:watch` 模式
- 需要重新设计 demo 目录下的代码演示功能
- 需要使用 playwright MCP 测试页面交互
- 直接修改+构建就能生效（热更新环境）

**开发环境特点**：

- 支持热更新，修改代码后自动重新构建
- 需要验证页面内容的交互输出和日志
- 使用 playwright 进行自动化测试

**下一步任务**：

1. 重新设计 demo 目录结构和功能
2. 实现交互式演示功能
3. 使用 playwright 验证功能正确性
4. 确保日志输出符合预期

**项目维护经验**：

- 开发过程中会产生备份文件，需要及时清理
- 构建产物会包含源码的所有文件，需要注意清理
- git 暂存区管理很重要，避免提交不必要的文件
- 文件清理后要重新构建和测试，确保项目完整性

**开发工作流程**：

- 用户习惯使用 `demo:watch` 进行开发
- 期望代码修改后能立即生效
- 需要通过 playwright 进行自动化测试验证

### demo:watch 热更新修复（2025-07-10）

**问题发现**：
用户报告 `demo:watch` 脚本存在热更新问题，源代码修改后没有正确触发构建和复制。

**根本原因分析**：

1. **竞争条件**：TypeScript 编译器 `--watch` 模式与 chokidar 监听产生冲突
2. **循环触发**：监听 `dist` 目录变化可能导致无限循环构建
3. **缺乏防抖机制**：没有正确的 debounce 处理，导致频繁触发
4. **进程管理不当**：多个构建进程可能同时运行

**解决方案**：

**创建了专用的 demo:watch 脚本**：

- 文件：`scripts/demo-watch.js`
- 统一监听机制：只监听 `src` 目录变化
- 改进的防抖机制：500ms debounce + 文件写入稳定性检查
- 优雅的进程管理：正确处理构建进程启动、终止和错误
- 顺序执行：确保 初始构建 → 复制 → 启动服务器 → 开始监听

**修改 package.json**：

```json
"demo:watch": "node scripts/demo-watch.js"
```

**关键技术细节**：

- 使用 `chokidar` 的 `awaitWriteFinish` 选项避免文件写入过程中的触发
- 实现 `debouncedCopy()` 函数，避免频繁复制操作
- 添加 `isBuilding` 标志防止并发构建
- 优雅退出处理，确保所有子进程正确终止

**ESLint 配置优化**：

- 在 `eslint.config.js` 中为 `**/*.js` 文件添加 Node.js 定时器全局变量
- 添加 `setTimeout`、`clearTimeout` 等全局变量支持

**测试验证**：

- 创建了测试脚本 `scripts/test-watch.js` 验证文件监听机制
- 确认修改 `src` 文件后能正确触发构建和复制
- 所有 168 个测试通过，ESLint 和 TypeScript 检查通过

**工作流程优化**：

```
修改 src 文件 → 触发构建 → 构建成功 → 自动复制到 demo/static → 浏览器自动更新
```

**经验教训**：

1. **避免多重监听**：不要同时使用 TypeScript watch 和 chokidar 监听
2. **防抖是关键**：文件系统事件需要适当的防抖处理
3. **进程管理重要**：确保子进程的正确启动和终止
4. **测试先行**：创建测试脚本验证修复效果

**用户体验提升**：

- 热更新响应更快，减少了不必要的构建延迟
- 避免了构建冲突和无限循环问题
- 提供了清晰的构建状态反馈

### 脚本目录重构（2025-07-10）

**背景**：
用户指出测试脚本应该与正式脚本分开管理，需要重构 scripts 目录结构。

**重构内容**：

1. **创建 tests 目录**：`scripts/tests/` 用于存放测试脚本
2. **移动测试脚本**：`scripts/test-watch.js` → `scripts/tests/test-watch.js`
3. **修复路径问题**：更新测试脚本中的相对路径（`../` → `../../`）
4. **创建说明文档**：`scripts/README.md` 详细说明目录结构和使用方法

**最终目录结构**：

```
scripts/
├── README.md              # 说明文件
├── copy-dist-to-demo.js   # 正式脚本：复制 dist 到 demo
├── demo-watch.js          # 正式脚本：demo 热更新
└── tests/                 # 测试脚本目录
    └── test-watch.js      # 测试脚本：文件监听测试
```

**脚本分类原则**：

- **正式脚本**：项目正常运行需要的脚本，通过 npm scripts 调用
- **测试脚本**：开发调试使用的脚本，用于验证功能或排查问题

**命名规范**：

- 正式脚本：功能导向命名，如 `demo-watch.js`
- 测试脚本：`test-` 前缀，如 `test-watch.js`
- 目录名：使用复数形式 `tests/`

**路径修复经验**：

- 测试脚本移动到子目录后，需要更新 `__dirname` 的相对路径
- 从 `scripts/` 到 `scripts/tests/` 需要额外的 `../`
- 测试后确认路径指向正确的项目根目录

**文档完善**：

- 创建 `scripts/README.md` 说明文件
- 详细记录每个脚本的功能、用途和调用方式
- 提供使用说明和注意事项

**用户体验改进**：

- 清晰的目录结构，便于区分正式脚本和测试脚本
- 详细的文档说明，便于新开发者理解和使用
- 标准化的命名规范，提高代码可维护性

### JSON 解析错误处理（2025-07-10）

**问题现象**：
API 返回 400 错误：`invalid_request_error` - "no low surrogate in string"

**根本原因**：
Unicode 字符编码问题，通常发生在：

1. **不完整的 emoji 或特殊字符**：UTF-16 编码需要高位和低位代理对
2. **文件编码损坏**：包含损坏的 Unicode 字符
3. **字符串截断**：在不正确的位置截断包含特殊字符的字符串

**解决经验**：

- 避免在代码中使用复杂的 emoji 或特殊 Unicode 字符
- 确保文件编码为标准 UTF-8
- 处理字符串时注意完整性，避免在多字节字符中间截断
- 使用工具验证文件编码的正确性

**预防措施**：

- 代码审查时注意特殊字符的使用
- 使用 ESLint 规则限制非 ASCII 字符
- 在处理用户输入时进行字符验证和清理

### 指纹测试框架实现（2025-07-10）

**背景**：
用户需要创建一个基于输入输出对的集成测试框架，用于验证流式 Markdown 渲染器的行为一致性。

**设计决策**：

1. **目录命名**：`io-cases/` 而不是 `cases/`，更清晰地表达输入输出测试的含义

2. **测试数据结构**：
   - `input.md` - Markdown 输入文本
   - `config.json` - 渲染器配置（包含 inputDelay 控制输入速率）
   - `expected-outputs/` - 每个字符输入后的预期 HTML 输出
   - `expected-logs.json` - 可选的日志验证

3. **关键技术特点**：
   - **逐字符验证**：每个字符输入后都验证 DOM 输出
   - **输入速率控制**：通过 `inputDelay` 配置控制字符间延迟
   - **类型适配**：将 `Record<string, string>` 转换为 `Map<string, string>`
   - **详细错误信息**：失败时提供具体字符位置和差异

**实现要点**：

- 测试加载器：从文件系统加载测试用例
- 测试运行器：执行流式输入并验证输出
- 输出生成器：生成预期输出文件
- 主测试文件：Vitest 集成

**使用方法**：

```bash
# 运行指纹测试
npm test tests/integration/fingerprint.test.ts

# 测试会自动生成 actual-outputs 目录用于对比
# 预期输出需要手动创建或通过专门的生成脚本创建
```

**价值**：
确保渲染器在各种输入场景下的行为一致，特别适合验证增量解析和延迟确认机制的正确性。

### 架构重大调整（2025-01-10）

**背景**：
原架构过度设计，使用缓冲管理器延迟处理。经过指纹测试发现，简单直接的方案更有效。

**新设计理念**：

1. **乐观更新**：看到 `*` 就预测是加粗，立即准备渲染
2. **即时响应**：每个字符输入立即产生 DOM 快照
3. **零缓冲**：移除缓冲管理器，直接处理

**核心改变**：

- 移除缓冲管理器模块
- 简化为：增量解析器 → 渲染引擎
- 实现乐观预测逻辑

**测试用例更新**：

- 输入格式：逗号分隔的字符序列 `*,*,b,o,l,d,*,*`
- 预期输出：前两个 `*` 输出空，从 `b` 开始输出 `<strong>` 包裹的内容

**影响**：

- 架构更简单，代码更少
- 响应更快，无延迟
- 测试更直观，一个输入对应一个输出

### 指纹测试框架重构（2025-01-10）

**关键发现**：
用户需要的是输入输出的精确对比测试，而不是复杂的测试运行器。

**重构内容**：

1. **分离预期和实际输出**
   - `expected-outputs/` - 存储预期的 HTML 输出
   - `actual-outputs/` - 运行时生成的实际输出（加入 .gitignore）
   - 便于对比和调试失败的测试

2. **简化测试架构**
   - 删除冗余的 `test-runner.ts` 和相关文件
   - 创建专门的 `fingerprint-runner.ts` 处理测试运行
   - 保留 `test-case-loader.ts` 负责加载测试用例

3. **测试理念转变**
   - 从"运行测试"转变为"生成快照并对比"
   - 每个字符输入对应一个完整的 DOM 快照
   - 测试失败时保留 actual-outputs 方便调试

**用户工作习惯**：

- 期望直接看到输入输出对比
- 需要精确控制每个字符的输入时机
- 重视测试的可视化和可调试性

### 当前实现与目标的差距（2025-01-10）

**现状**：

- 当前实现仍是保守策略：`*` 显示为 span，而非乐观更新
- 测试框架已准备好，但核心代码未实现乐观更新

**待完成**：

1. 重构核心代码实现乐观更新
2. 移除缓冲管理器相关代码
3. 修改增量解析器支持乐观预测

**测试驱动开发启示**：

- 通过编写预期输出，明确了期望的行为
- 测试先行帮助发现了架构设计的问题
- 指纹测试提供了清晰的验收标准

### 乐观更新实现（2025-01-10）

**完成的工作**：

1. **创建乐观解析器**（`optimistic-parser.ts`）
   - 实现了乐观预测机制
   - 支持预期违背的即时修正
   - 零缓冲设计，每个字符立即响应

2. **博客文档更新**
   - 加入"预期违背"（Expectation Violation）概念
   - 详细解释了乐观更新的哲学和机制
   - 更新了两篇技术博客，强调简化设计的价值

**预期违背机制**：

用户提出的重要概念，指某些字符会立即打破格式预期：

- `* + 空格` → 不可能是斜体，立即输出星号
- `** + 换行` → 不可能是加粗，立即输出
- 修正速度快于人眼识别（< 50ms）

**设计哲学**：

- 乐观但不盲目
- 违背即机会（快速学习和调整）
- 在不确定性中寻找最佳路径

**ESLint 修复经验**：

- 未使用参数需要用 `_` 前缀，如 `_char`
- 格式问题可用 `npm run lint -- --fix` 自动修复
- 保持代码质量标准的一致性
- TypeScript 事件需要包含 timestamp 属性

### 架构演进：快照驱动的渲染（2025-01-10）

**用户明确的架构要求**：

1. **真正的乐观更新**
   - 移除"POTENTIAL\_"概念，直接预测
   - 看到 `*` 就是斜体，看到 `**` 就是加粗
   - 不要犹豫，直接执行

2. **增量重构原则**
   - 保留现有代码，创建新实现
   - 渐进式演进，不破坏现有功能
   - 新旧并存，逐步切换

3. **令牌-快照系统**
   - 每个令牌对应一个完整的DOM快照
   - 解析器发出令牌时，同时生成DOM快照
   - 快照包含完整的DOM结构状态

4. **DOM差分模块**
   - 新增专门的DOM差分计算模块
   - 内部维护上一次的DOM状态
   - 通过diff计算最小化更新操作
   - 只更新真正变化的部分

**架构流程**：

```
输入字符 → 乐观解析器 → 令牌+快照 → DOM差分模块 → 最小化DOM更新
```

**关键洞察**：

- 用户强调的是"快照驱动"的渲染方式
- 不是增量令牌，而是完整快照的差分
- 这样可以更好地处理复杂的DOM结构变化

<!-- 最后回顾: 2025-01-10T03:35:00+08:00 -->
<!-- 记录快照驱动渲染架构要求，明确增量重构原则 -->
