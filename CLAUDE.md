# Markdown River 项目记忆

## 项目核心

### 问题定义

这是一个解决 **AI 聊天应用中 Markdown 流式渲染闪烁问题** 的前端库项目。

**一句话概括**：开发流式 Markdown 渲染器，解决 AI 聊天中因逐字符渲染导致的格式符号闪烁问题。

**根本问题**：

- 后端以字符流方式返回 Markdown 文本
- 传统框架（如 react-markdown）逐字符渲染时，格式符号会先显示为普通字符，识别后突然转换为格式，造成视觉闪烁
- 简单的缓存策略会导致输出卡顿，影响用户体验

**具体表现**：当 AI 返回 `**加粗文本**` 时，用户会先看到星号，然后突然变成加粗格式，体验很差。

### 解决思路

通过实现智能的增量解析器和平滑的渲染调度，在保持流畅输出的同时避免格式符号的闪烁。

**核心方案**：智能缓冲延迟 + 预判解析 + 平滑输出

## 技术决策

### 架构设计

采用模块化架构，包含核心组件和支撑模块：

**核心组件**：

1. **缓冲管理器（智能仓库）**：环形缓冲区，支持回溯
2. **增量解析器（聪明大脑）**：智能预判，生成可能性令牌
3. **渲染调度器（节奏控制）**：控制输出速率，保持平滑

**支撑模块**：

- **DOM 管理器**：增量更新，批量操作
- **事件总线**：模块间通信，解耦架构
- **样式处理器**：自定义样式映射

### 关键特性

1. **智能预判**：不是确定性令牌，而是可能性令牌
2. **平滑输出**：单一目标，不让用户选择策略
3. **优雅回溯**：超时机制 + 自适应阈值
4. **样式映射**：支持自定义标签到 CSS 类的映射

## 实现要点

### 核心挑战

- **不确定性处理**：处理流式输入的格式预判
- **速率控制**：在缓冲延迟和实时性间平衡
- **回溯机制**：最小化对用户体验的影响

### 技术栈选择理由

- **TypeScript**：类型安全，减少运行时错误
- **Vitest**：适合流式场景的测试，支持模拟异步流
- **原生 DOM API**：避免框架依赖，更直接的性能控制
- **事件驱动架构**：模块解耦，易于扩展

### 数据流设计

```
输入流 → 缓冲管理器 → 增量解析器 → 令牌流 → 渲染调度器 → DOM更新 → 输出
```

关键机制：

1. **智能缓冲**：基于上下文决定是否缓冲
2. **可能性令牌**：`POTENTIAL_BOLD` 而不是 `BOLD_START`
3. **自适应超时**：根据输入速率动态调整
4. **平滑调度**：保持稳定的输出节奏

## 开发经验

### 代码规范

1. **ESLint + Prettier**：严格的代码格式检查
2. **TypeScript 严格模式**：避免 `any` 类型，使用 `unknown`
3. **中文注释**：代码注释和文档使用中文
4. **测试先行**：每个模块都有完整的单元测试

### 项目结构

```
src/
├── core/                # 核心组件
├── infrastructure/      # 基础设施（事件总线等）
├── types/              # 类型定义
└── utils/              # 工具函数

tests/
├── core/               # 核心组件测试
└── infrastructure/     # 基础设施测试

qa/                     # 问答文档目录
blog/                   # 技术博客文章
```

### 开发流程

1. 先定义 TypeScript 接口
2. 实现核心功能
3. 编写全面的单元测试
4. 运行完整的检查流程（lint + typecheck + test）

## 使用场景

### 主要应用

- AI 对话界面的响应渲染
- 实时协作编辑器
- 流式内容展示

### 集成方式

```javascript
// 基础使用
const renderer = new StreamingMarkdownRenderer({
  styleMap: new Map([
    ['h1', 'text-4xl font-bold'],
    ['strong', 'font-semibold text-gray-900'],
  ]),
});

// 处理流式输入
renderer.write(chunk);
renderer.end();
```

## 开发指南

### 命令速查

```bash
npm run dev        # 开发模式
npm run build      # 构建生产版本
npm run test       # 运行测试
npm run lint       # 代码检查
npm run typecheck  # 类型检查
npm run check      # 完整检查（lint + typecheck + test）
```

### 注意事项

1. 所有代码必须通过 `npm run check`
2. 使用 `unknown` 而不是 `any` 类型
3. 事件系统支持优先级、过滤、异步处理
4. 测试要覆盖边界情况和错误处理

## 项目状态

### 已完成

- ✅ 需求文档编写（REQUIREMENTS.md）
- ✅ 架构设计文档（ARCHITECTURE.md）- 已简化更新
- ✅ 博客文章编写（两篇技术博客）
- ✅ 项目基础结构搭建
- ✅ 事件总线模块（完整实现 + 测试）
- ✅ 缓冲管理器模块（buffer-manager + 测试）
- ✅ DOM 管理器模块（dom-manager + 测试）
- ✅ 样式处理器模块（style-processor + 测试）
- ✅ 问答文档（qa/what-is-ring-buffer.md）
- ✅ 问答文档（qa/what-is-commonmark.md）

### 核心洞察

1. **延迟是特性，不是缺点**：通过智能缓冲延迟获得预判时间
2. **单一目标原则**：只追求平滑，不给用户选择的困扰
3. **令牌系统精髓**：可能性令牌 + 确认机制 + 撤销机制

## 架构要点速查

### 事件总线设计

- **优先级排序**：高优先级监听器先执行
- **条件过滤**：支持过滤条件决定是否执行
- **错误隔离**：单个监听器出错不影响其他监听器
- **异步支持**：完整的 Promise 支持
- **内存管理**：自动清理一次性监听器
- **自定义实现**：不使用第三方库（如 mitt），保持完全控制
- **同步等待**：emit 方法会等待所有异步监听器执行完成

### 关键设计模式

- **事件驱动**：模块间通过事件总线通信
- **策略模式**：令牌处理的不同策略
- **状态机模式**：解析器的状态管理（待实现）
- **观察者模式**：事件监听机制

### 开发规约

- **类型安全**：严格的 TypeScript 类型检查
- **测试覆盖**：每个模块都要有完整测试
- **文档同步**：代码更新同步更新文档
- **中文优先**：注释和文档优先使用中文
- **文件命名**：使用小写中划线格式（kebab-case），如 `buffer-manager.ts`

## 技术决策记录

### 事件总线实现（2025-07-09）

**决策**：使用自定义实现而非 mitt 等第三方库

**原因**：

1. mitt 不适合处理复杂的异步等待需求
2. 自定义实现能完全控制优先级、过滤、异步等特性
3. 测试证明原始实现已经满足所有需求

**经验教训**：

- 不是所有场景都需要第三方库
- 当需求复杂时，自定义实现可能更简单
- 充分的测试覆盖是决策的重要依据

### TypeScript 配置问题（2025-07-09）

**问题发现**：

- tsconfig.json 排除了 tests 目录，导致测试文件的类型错误未被检测
- 将 tests 加入 include 后，构建时会生成测试文件的 .js 和 .d.ts 文件

**解决方案**：

1. **开发环境**：tsconfig.json 包含测试文件进行类型检查
2. **构建环境**：需要单独的 tsconfig.build.json 排除测试文件

**关键配置**：

```json
// tsconfig.json - 用于开发和类型检查
{
  "include": ["src/**/*", "tests/**/*"],
  "exclude": ["node_modules", "dist"]
}

// tsconfig.build.json - 用于构建
{
  "extends": "./tsconfig.json",
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

**常见错误模式**：

- 箭头函数返回值类型错误：`() => results.push(1)` 返回 number 而非 void
- 修复方式：使用花括号 `() => { results.push(1); }`

### 缓冲管理器实现（2025-07-09）

**决策**：实现环形缓冲区作为核心数据结构

**设计要点**：

1. **环形缓冲区**：固定大小，避免内存无限增长
2. **自动覆盖**：缓冲区满时自动覆盖最旧数据
3. **支持回溯**：可以回退读取位置，重新读取数据
4. **事件集成**：与事件总线集成，支持写入、读取、回溯、清空事件

**实现细节**：

- 使用字符数组作为底层存储
- 读写位置使用模运算实现循环
- 创建独立的事件数据类型 `buffer-events.ts`
- 完整的单元测试覆盖所有功能

**测试策略**：

- 环形缓冲区的行为需要特别注意边界情况
- 测试用例要考虑缓冲区满时的覆盖行为
- 事件断言使用 `expect.objectContaining` 忽略时间戳

### 架构简化决策（2025-07-09）

**背景**：原架构设计文档过于复杂，包含太多模块

**决策**：简化为三个核心组件 + 三个支撑模块

**核心组件**：

1. 缓冲管理器（已实现）
2. 增量解析器（待实现）
3. 渲染调度器（待实现）

**理念**：与其事后修正，不如提前预判

### DOM 管理器实现（2025-07-09）

**决策**：实现高性能的 DOM 管理器

**设计要点**：

1. **批处理机制**：通过 requestAnimationFrame 优化渲染
2. **虚拟节点缓存**：减少 DOM 查询操作
3. **操作队列**：异步批量处理 DOM 操作
4. **智能节点 ID**：使用 data-node-id 属性追踪节点

**实现细节**：

- 所有 DOM 操作都进入队列，批量执行
- 使用延迟批处理（默认 16ms，一帧时间）
- 支持手动刷新和最大批处理大小限制
- 通过事件系统通知操作完成

**测试策略**：

- 使用 jsdom 环境进行 DOM 测试
- 测试批处理、缓存、事件发射等核心功能
- 覆盖边界情况如特殊字符、深层嵌套等

### 样式处理器实现（2025-07-09）

**决策**：实现简洁的样式映射管理器

**设计理念**：

- 保持简单，不过度设计
- 支撑模块不需要复杂的事件系统
- 核心功能是维护标签到 CSS 类的映射

**设计要点**：

1. **默认样式支持**：提供 Tailwind CSS 风格的默认样式
2. **主题系统**：支持多主题切换和管理
3. **灵活配置**：支持 Map 和对象两种配置方式
4. **工具方法**：提供便捷的静态辅助方法

**实现细节**：

- 使用 Map 作为底层存储结构
- 主题切换时保留默认样式作为基础
- 导出/导入主题功能便于复用
- 22 个完整的单元测试覆盖所有功能

### 文档编写风格

**问答文档（qa 目录）**：

- 使用大白话，通俗易懂
- 多用生活化的比喻（如旋转寿司店）
- 图形化展示复杂概念
- 结合项目实际使用场景

<!-- 最后回顾: 2025-07-09 -->
<!-- 样式处理器模块已完成，实现了简洁高效的样式映射管理 -->
