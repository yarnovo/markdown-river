# Markdown River 架构设计文档

## 1. 系统概述

Markdown River 是一个专门解决流式 Markdown 渲染闪烁问题的前端库。它通过**乐观更新**策略和实时渲染，避免格式符号的视觉闪烁。

### 1.1 设计目标

- **无闪烁渲染**：格式符号不会先显示后消失
- **实时响应**：每个输入立即产生输出
- **乐观更新**：预测用户意图，提前渲染
- **简单直接**：最小化设计，避免过度工程
- **易集成**：简洁的 API，支持多种前端框架

### 1.2 核心理念

**乐观更新，立即响应**

- 看到 `*` 就预测是加粗，立即准备 `<strong>` 标签
- 每个字符输入都产生一个完整的 DOM 快照
- 没有缓冲，没有延迟，直接渲染

## 2. 极简架构

### 2.1 架构概览

系统采用极简的两层架构：

```
┌─────────────────────────────────────────────────┐
│              用户 API 接口                       │
├─────────────────────────────────────────────────┤
│                核心组件层                         │
│  ┌──────────────┐         ┌──────────────────┐ │
│  │  增量解析器  │ ──────> │    渲染引擎      │ │
│  │  (乐观预测)  │         │   (即时渲染)     │ │
│  └──────────────┘         └──────────────────┘ │
├─────────────────────────────────────────────────┤
│                支撑模块层                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────────┐ │
│  │ 事件总线 │  │ DOM管理器│  │  样式处理器  │ │
│  └──────────┘  └──────────┘  └──────────────┘ │
└─────────────────────────────────────────────────┘
```

### 2.2 数据流

```
字符输入 → 增量解析器 → 令牌流 → 渲染引擎 → DOM快照
   ↓          ↓           ↓         ↓          ↓
事件总线 ←─────────────────────────────────────
```

## 3. 核心组件设计

### 3.1 增量解析器（Incremental Parser）

**职责**：逐字符解析输入，生成乐观的令牌流

**核心特性**：

- **乐观预测**：看到 `*` 立即预测为加粗开始
- **状态管理**：维护当前的解析上下文
- **即时输出**：每个字符都产生令牌

**工作原理**：

```typescript
// 输入: *
// 输出: TOKEN_POTENTIAL_BOLD_START

// 输入: **
// 输出: TOKEN_BOLD_START

// 输入: **b
// 输出: TOKEN_BOLD_START, TOKEN_TEXT('b')
```

### 3.2 渲染引擎（Render Engine）

**职责**：将令牌流转换为 DOM 元素

**核心特性**：

- **即时渲染**：收到令牌立即更新 DOM
- **快照生成**：每次更新都是完整的 DOM 状态
- **简单直接**：没有批处理，没有延迟

**工作原理**：

```typescript
// 令牌: TOKEN_BOLD_START, TOKEN_TEXT('b')
// DOM: <strong>b</strong>

// 令牌: TOKEN_BOLD_START, TOKEN_TEXT('bo')
// DOM: <strong>bo</strong>
```

## 4. 支撑模块

### 4.1 事件总线（Event Bus）

- 组件间通信
- 调试和监控
- 插件系统支持

### 4.2 DOM 管理器（DOM Manager）

- 高效的 DOM 操作
- 虚拟节点管理
- 性能优化

### 4.3 样式处理器（Style Processor）

- 样式映射管理
- 主题支持
- 自定义样式

## 5. 乐观更新策略

### 5.1 加粗文本示例

输入序列：`**bold**`

| 字符 | 解析状态 | DOM 输出                |
| ---- | -------- | ----------------------- |
| `*`  | 等待确认 | 空                      |
| `*`  | 确认加粗 | 空                      |
| `b`  | 加粗内容 | `<strong>b</strong>`    |
| `o`  | 加粗内容 | `<strong>bo</strong>`   |
| `l`  | 加粗内容 | `<strong>bol</strong>`  |
| `d`  | 加粗内容 | `<strong>bold</strong>` |
| `*`  | 等待结束 | `<strong>bold</strong>` |
| `*`  | 确认结束 | `<strong>bold</strong>` |

### 5.2 错误恢复

如果预测错误（如 `*not bold*`），系统会：

1. 识别出不是有效的 Markdown 格式
2. 回退到普通文本渲染
3. 输出：`*not bold*`

## 6. API 设计

### 6.1 基础使用

```typescript
const renderer = new StreamingMarkdownRenderer({
  container: document.getElementById('output'),
  styleMap: new Map([
    ['strong', 'font-bold'],
    ['em', 'italic'],
  ]),
});

// 逐字符输入
renderer.write('*');
renderer.write('*');
renderer.write('b');
// ...

renderer.end();
```

### 6.2 事件监听

```typescript
renderer.on('render', snapshot => {
  console.log('DOM 快照:', snapshot);
});

renderer.on('token', token => {
  console.log('生成令牌:', token);
});
```

## 7. 性能考虑

### 7.1 优化策略

1. **零缓冲**：没有缓冲延迟，立即响应
2. **轻量解析**：最小的状态机，快速决策
3. **直接渲染**：跳过中间层，直达 DOM

### 7.2 内存管理

- 无缓冲区，内存占用最小
- 及时清理临时状态
- 避免内存泄漏

## 8. 扩展性

### 8.1 插件接口

```typescript
interface Plugin {
  name: string;
  onToken?: (token: Token) => void;
  onRender?: (dom: Element) => void;
}
```

### 8.2 自定义解析规则

- 支持添加新的 Markdown 语法
- 可以覆盖默认的解析行为
- 灵活的令牌系统

## 9. 测试策略

### 9.1 单元测试

- 解析器的各种输入场景
- 渲染引擎的输出验证
- 边界情况处理

### 9.2 集成测试

- 端到端的渲染测试
- 性能基准测试
- 兼容性测试

### 9.3 指纹测试

- 输入输出对比测试
- 每个字符一个快照
- 确保行为一致性

## 10. 设计决策记录

### 10.1 移除缓冲管理器（2025-01-10）

**原因**：

- 过度设计，增加复杂性
- 延迟不是必需的
- 简单直接更有效

**影响**：

- 架构更简单
- 响应更快速
- 代码更易懂

### 10.2 采用乐观更新（2025-01-10）

**原因**：

- 更好的用户体验
- 避免闪烁
- 符合用户预期

**实现**：

- 预测用户意图
- 提前渲染结构
- 必要时回退
