# Markdown River 项目记忆

## 项目核心

### 问题定义

这是一个解决 **AI 聊天应用中 Markdown 流式渲染闪烁问题** 的前端库项目。

**一句话概括**：开发流式 Markdown 渲染器，解决 AI 聊天中因逐字符渲染导致的格式符号闪烁问题。

**根本问题**：

- 后端以字符流方式返回 Markdown 文本
- 传统框架逐字符渲染时，格式符号会先显示为普通字符，识别后突然转换为格式，造成视觉闪烁
- 简单的缓存策略会导致输出卡顿，影响用户体验

**解决思路**：通过乐观更新和字符-令牌一一对应原则，在保持流畅输出的同时避免格式符号闪烁。

## 技术决策

### 架构设计

**V2 架构（当前）**：

- **乐观解析器**：移除缓冲延迟，直接预测格式并发送确定性令牌
- **快照渲染器**：每个令牌生成完整 DOM 快照
- **DOM 差分系统**：计算最小化 DOM 操作
- **事件驱动架构**：完全解耦的组件通信

**数据流**：

```
字符输入 → 乐观解析器 → [parser:token] → 快照渲染器 → [snapshot:updated] → DOM差分 → DOM操作
```

### 关键特性

1. **乐观更新**：看到 `*` 立即预测为斜体，看到 `**` 立即预测为加粗
2. **字符-令牌一一对应**：每个输入字符必须产生对应的令牌输出
3. **索引化令牌**：多字符序列（如 `**`）通过索引令牌支持
4. **格式确认机制**：空白字符和标点符号确认格式结束
5. **修正令牌系统**：支持 CORRECTION_TO_BOLD_START 等修正令牌

## 实现要点

### 技术栈

- **TypeScript**：类型安全，减少运行时错误
- **Vitest**：流式场景测试，支持模拟异步流
- **原生 DOM API**：避免框架依赖，更直接的性能控制
- **事件驱动架构**：模块解耦，易于扩展

### 项目结构

```
src/
├── core/                # 核心组件（乐观解析器、快照渲染器、DOM差分）
├── infrastructure/      # 基础设施（事件总线、样式处理器、DOM管理器）
└── types/              # 类型定义

tests/
├── core/               # 核心组件测试
├── infrastructure/     # 基础设施测试
└── integration/        # 集成测试和指纹测试
```

## 使用方式

```javascript
const renderer = new StreamingMarkdownRenderer({
  container: document.getElementById('output'),
  styleMap: new Map([
    ['h1', 'text-4xl font-bold'],
    ['strong', 'font-bold'],
    ['em', 'italic'],
  ]),
  debug: true,
});

// 处理流式输入
renderer.write('**Bold');
renderer.write(' text**');
renderer.end();
```

## 开发指南

### 命令速查

```bash
npm run dev        # 开发模式
npm run build      # 构建生产版本
npm run test       # 运行测试
npm run check      # 完整检查（lint + typecheck + test）
npm run demo:watch # 热更新演示
```

### 代码规范

1. **ESLint + Prettier**：严格的代码格式检查
2. **TypeScript 严格模式**：避免 `any` 类型，使用 `unknown`
3. **中文注释**：代码注释和文档使用中文
4. **测试先行**：每个模块都有完整的单元测试

## 项目状态

### 当前状态（2025-07-10）

**项目已完成升级到 V2 架构 🎉**

已成功实现乐观更新和字符-令牌一一对应原则：

- **乐观解析器** ✅ - 彻底移除缓冲延迟，实现即时响应
- **字符-令牌一一对应** ✅ - 严格遵循每个字符产生对应令牌的约束
- **索引化令牌系统** ✅ - 支持多字符序列的精确处理
- **格式确认机制** ✅ - 区分预期违背和格式确认
- **修正令牌系统** ✅ - 支持 CORRECTION_TO_BOLD_START 等修正令牌
- **快照渲染器** ✅ - 每个令牌生成完整 DOM 快照
- **DOM 差分系统** ✅ - 计算最小化 DOM 操作
- **事件驱动架构** ✅ - 完全解耦的组件通信

**技术指标**：

- 测试覆盖率：231/231 (100%)
- 代码质量：ESLint + TypeScript 严格模式
- 架构模块：3个核心组件 + 支撑模块
- 文档完整性：完整的技术文档和使用指南

**重要设计决策（2025-07-10）**：

- **不支持嵌套格式**：为了保持简单性，决定不支持斜体和粗体的互相嵌套
- **乐观预测原则**：严格遵循"一个输入对应一个token输出"的原则
- **累积正确性**：最终输出的token序列累加后应该是正确的，这是核心目标

### 未来优化方向

- 高级格式支持（表格、代码块语法高亮）
- 智能缓冲策略优化
- 性能优化（大量文本处理）
- 插件系统支持

## 架构要点

### 事件系统设计

- **优先级排序**：高优先级监听器先执行
- **错误隔离**：单个监听器出错不影响其他监听器
- **异步支持**：完整的 Promise 支持
- **自定义实现**：不使用第三方库，保持完全控制

### 关键设计模式

- **事件驱动**：模块间通过事件总线通信
- **策略模式**：令牌处理的不同策略
- **状态机模式**：解析器的状态管理
- **观察者模式**：事件监听机制

## 技术决策记录

### 字符-令牌一一对应原则（2025-07-10）

**核心约束**：每个输入字符必须产生对应的令牌输出

**关键实现**：

1. **索引化令牌**：`{ type: 'BOLD_END', index: 1 }` 和 `{ type: 'BOLD_END', index: 2 }`
2. **格式确认**：空白字符和标点符号确认格式结束
3. **修正令牌**：CORRECTION_TO_BOLD_START 等处理预期违背

### 乐观更新设计哲学（2025-07-10）

**核心理念**：

- 看到 `*` 立即预测为斜体，看到 `**` 立即预测为加粗
- 在不确定的情况下保持格式，而不是回退到原始符号
- 用户会感知到格式变化，但关键是避免符号闪烁

### 预期管理机制

**核心概念**：处理 Markdown 格式歧义的机制

**流程**：

1. **预期建立**：看到第一个 `*` → 进入 `EXPECT_BOLD_SECOND` 状态
2. **预期验证**：检查下一个字符是否为 `*`
3. **预期实现**：如果是 `*` → 确认加粗
4. **预期违背**：如果不是 `*` → 修正为斜体

**关键洞察**：这是一个中间状态，允许解析器在不完整信息下做出最佳预测，同时保留修正能力。

### 文档维护原则（2025-07-10）

**用户反馈重点**：

- 架构文档的示例必须与测试用例严格一致
- 加粗文本 `**bold**` 的最后两个 `*` 应该输出带索引的 `BOLD_END` 令牌
- 斜体文本 `*italic*` 后跟空格时，空格应该确认斜体结束并递归处理
- 文档示例要准确反映字符-令牌一一对应原则

**维护方法**：

1. 任何架构示例都要参考对应的测试用例
2. 特别关注多字符序列的索引化处理
3. 确保递归处理逻辑在文档中正确体现

## 开发经验

### 开发流程

1. 先定义 TypeScript 接口
2. 实现核心功能
3. 编写全面的单元测试
4. 运行完整的检查流程

### 测试策略

- **单元测试**：每个模块的独立功能测试
- **集成测试**：模块间协作测试
- **指纹测试**：输入输出对比测试框架
- **边界测试**：特殊情况和错误处理

### 常见问题解决

1. **TypeScript 配置**：开发环境包含测试文件，构建环境排除
2. **事件系统类型**：使用类型断言解决复杂事件类型
3. **一一对应原则**：严格遵循每个字符对应一个令牌
4. **热更新问题**：统一监听机制，避免竞争条件
5. **文档与测试一致性**：架构文档的示例必须与测试用例保持一致
6. **嵌套格式支持**：斜体和加粗可以互相嵌套，需要智能的状态管理

## 项目价值

**解决的核心问题**：

- ✅ 彻底解决 AI 聊天应用中的 Markdown 流式渲染闪烁问题
- ✅ 建立了高性能、可扩展的事件驱动渲染架构
- ✅ 提供了完整的 TypeScript 类型系统
- ✅ 创建了可复用的技术组件

**技术创新**：

- 乐观更新机制：预测格式并立即渲染
- 字符-令牌一一对应原则：确保流式处理的精确性
- 索引化令牌系统：优雅处理多字符序列
- 快照驱动渲染：通过差分计算最小化 DOM 操作

**设计哲学**：

- 延迟是特性，不是缺点：通过智能预判获得平滑体验
- 单一目标原则：只追求平滑，不给用户选择的困扰
- 完成优于撤销：在不确定时保持格式，而不是回退

### 嵌套格式支持需求（2025-07-10）

**用户需求**：

- 支持 `**这是 *粗中有斜* 的文本**` - 加粗中嵌套斜体
- 支持 `*这是 **斜中有粗** 的文本*` - 斜体中嵌套加粗
- 支持 `***文本***` - 三星号复合格式

**技术挑战**：

- 当前实现在斜体中遇到 `*` 时会进入 `ENDING_ITALIC` 状态等待确认
- 这种等待机制阻止了嵌套格式的开始
- 需要在支持嵌套的同时保持基本格式结束逻辑正常

**实现思路**：

1. 在斜体中遇到 `*` 时，先乐观预测为新的斜体开始
2. 如果下一个字符是 `*`，修正为加粗
3. 如果下一个字符是确认字符，撤销并结束外层斜体
4. 如果下一个字符是其他字符，保持新的斜体开始

**关键洞察**：

- 嵌套支持是字符-令牌一一对应原则的扩展应用
- 需要更复杂的状态管理来处理多层嵌套
- 用户强调 CommonMark 规范支持嵌套，这是标准行为

**当前状态**：

- 基本的嵌套测试用例已添加，22/23 测试通过
- 成功恢复了基本的斜体和加粗功能
- 仍有一个嵌套测试失败：斜体中的 `**` 被当作普通文本处理
- 需要改进 `handleInItalicState` 中的 `*` 处理逻辑以支持嵌套

**技术细节**：

- 当前实现在斜体中遇到 `*` 时进入 `ENDING_ITALIC` 状态
- 但这阻止了嵌套格式的识别（如 `*text **bold** text*`）
- 需要在等待确认和支持嵌套之间找到平衡

**修复进展**（2025-07-10）：

- ✅ 成功恢复了基本的斜体和加粗功能
- ✅ 修复了代码质量问题（替换 `any` 类型）
- ✅ 删除了嵌套格式相关的测试用例
- ✅ 231/231 测试全部通过，项目重新稳定

**最终决策**：

- 决定不支持嵌套格式，保持解析器的简单性
- 避免复杂的状态管理带来的潜在问题
- 专注于核心目标：防止格式符号闪烁

## 用户特征与偏好

### 工作风格特点

- **极高的技术准确性要求**：对架构设计、代码实现的准确性要求极高
- **权衡取舍的智慧**：理解复杂性与可维护性之间的平衡，支持简化设计
- **规范意识强**：重视 CommonMark 规范，但能接受合理的简化
- **结果导向**：关注最终输出的正确性，理解"累积正确性"的概念

### 技术决策模式

- **乐观预测原则**：支持"立即预测，及时修正"的设计理念
- **一对一原则**：严格遵循"一个输入对应一个token输出"的约束
- **简单性优先**：在功能复杂性和系统稳定性之间选择后者
- **实用主义**：理解技术实现的权衡，不追求过度复杂的功能

### 沟通习惯

- **中文交流**：使用中文进行技术讨论
- **直接表达**：能够直接表达技术观点，如"保持简单"
- **上下文感知**：理解复杂技术问题的上下文，能够基于实际情况做决策
- **建设性反馈**：提供具体的技术建议和改进方向

### 技术理解深度

- **状态管理**：深刻理解状态机和上下文管理的复杂性
- **架构设计**：理解事件驱动架构和模块化设计的价值
- **测试驱动**：重视测试覆盖率和代码质量
- **性能意识**：关注渲染性能和用户体验

### 项目价值观

- **核心目标明确**：始终关注"防止格式符号闪烁"这一核心目标
- **用户体验优先**：理解流式渲染的用户体验挑战
- **技术债务控制**：支持删除复杂功能以降低技术债务
- **长期可维护性**：优先考虑代码的长期可维护性

## 重要技术洞察

### 关键设计原则

1. **乐观预测 + 及时修正**：这是解决流式渲染闪烁的核心策略
2. **字符-令牌一对一**：确保每个输入字符都有对应的输出令牌
3. **累积正确性**：最终输出序列的正确性比中间状态更重要
4. **简单性胜过完整性**：在功能完整性和系统简单性之间选择后者

### 状态管理智慧

- **上下文感知的重要性**：解析器需要基于上下文做出不同判断
- **状态复杂性的控制**：过度复杂的状态管理会导致难以维护的代码
- **边界情况的处理**：简化设计有助于减少边界情况的处理复杂度

### 架构演进经验

- **从 V1 到 V2**：从缓冲延迟到乐观预测的架构演进
- **测试驱动迭代**：通过测试用例驱动功能实现和优化
- **重构决策**：及时删除不必要的功能以保持架构清晰

<!-- 最后回顾: 2025-07-10T06:30:00+08:00 -->
<!-- 结论: 当前记忆已涵盖关键信息 -->
<!-- 本次对话核心：嵌套格式支持问题的解决 -->
<!-- 最终决策：选择简单性，不支持嵌套格式 -->
<!-- 用户特点：技术准确性要求极高，理解权衡取舍，支持简化设计 -->
<!-- 记忆更新状态：完整涵盖所有关键信息，无需进一步更新 -->
